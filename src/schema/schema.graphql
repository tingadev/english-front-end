# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AccessTokens {
  accessToken: String!
  refreshToken: String!
}

type Answers {
  answerContent: String
  keyAnswer: String
}

input AnswersGroupInput {
  answers: [AnswersInput!]
  description: String
  explaination: String
  id: String
  isNew: Boolean
  order: Float
  questionName: String
  result: String
}

input AnswersInput {
  answerContent: String
  keyAnswer: String
}

type Asset {
  createdAt: DateTime!
  name: String!
  path: String!
  type: String!
  url: String!
}

input AssetInput {
  name: String!
  type: String!
  typeFolder: MediaType!
}

input AudioSecondsInput {
  autdioSecs: Float
  displayOrder: Float
  partId: String
}

type Blog {
  author: User!
  blogName: String!
  content: String!
  createdAt: DateTime!
  deleteAt: DateTime
  displayOrder: Float!
  id: String!
  image: String
  link: String!
  metaTags: MetaTags
  testGroup: TestGroup!
  updatedAt: DateTime!
}

type Blogs {
  blogs: [Blog!]!
  nextCursor: String
  total: Float!
}

input BlogsSearchInput {
  authorId: String
  blogName: String
  cursor: String
  orderDirection: OrderDirection
  testGroupId: String
}

# Change password
input ChangePasswordInput {
  email: String!
  password: String!
  token: String!
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

enum EnglishCertificateType {
  ExtraCourses
  IELTS
  Support
  Toeic
  University
}

enum GroupType {
  Blog
  Landing
  Test
}

type ImpersonatingUser {
  tokens: AccessTokens!
  userId: String!
}

type Me {
  address: String
  blogs: [Blog!]!
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: String!
  impersonatingUser: ImpersonatingUser
  isVerified: Boolean
  lastName: String
  level: String

  # First + Last name
  name: String!
  password: String
  phone: String
  profileMediaUrl: String
  role: String!
  socialLinks: SocialLink
  updatedAt: DateTime!
  version: Float!
}

enum MediaType {
  Audio
  Image
  Video
}

type MetaTags {
  description: String
  imageUrl: String
}

input MetaTagsInput {
  description: String
  imageUrl: String
}

type Mutation {
  changePassword(data: ChangePasswordInput!): Me!
  createBlog(data: NewBlogInput!): Blog!
  createListTestQuestions(data: TestQuestionInputIds!): [TestQuestion!]!
  createPart(data: NewPartInput!): Part!
  createQuestion(data: NewQuestionInput!): Question!
  createTest(data: NewTestInput!): Test!
  createTestCategory(data: NewTestCategoryInput!): TestCategory!
  createTestGroup(data: NewTestGroupInput!): TestGroup!
  createTestQuestion(data: TestQuestionInputId!): TestQuestion!
  createUser(data: NewUserInput!): User!
  deleteBlog(id: String!): String!
  login(email: String!, password: String!): Me!
  logout: Boolean!
  removeFromCat(id: String!): Test!
  removePart(id: String!): String!
  removeQuestion(id: String!): String!
  removeTest(id: String!): String!
  removeTestCategory(id: String!): String!
  removeTestGroup(id: String!): String!
  removeTestQuestion(id: String!): String!
  uniqueLinkBlog(link: String!): Boolean!
  uniqueLinkTestGroup(link: String!): Boolean!
  updateBlog(data: NewBlogInput!): Blog!
  updateBlogOrder(data: UpdateBlogOrderInput!): Blog!
  updateMe(data: UpdateMeInput!): Me!
  updatePart(data: NewPartInput!): Part!
  updateQuestion(data: NewQuestionInput!): Question!
  updateTest(data: NewTestInput!): Test!
  updateTestCategory(data: NewTestCategoryInput!): TestCategory!
  updateTestGroup(data: NewTestGroupInput!): TestGroup!
  updateTestQuestion(data: TestQuestionInputId!): TestQuestion!
  updateTests(data: TestsUpdateInput!): [Test!]!
  uploadMedia(data: AssetInput!): Asset!
}

input NewBlogInput {
  authorId: String!
  blogName: String!
  content: String!
  id: String
  image: String
  link: String!
  metaTags: MetaTagsInput
  testGroupId: String!
}

input NewPartInput {
  certificateType: EnglishCertificateType!
  description: String!
  displayOrder: Float
  id: String
  partName: String!
  skillType: SkillsType!
}

input NewQuestionInput {
  answers: [AnswersInput!]!
  answersGroup: [AnswersGroupInput!]
  audioSec: Float!
  audioSecVN: Float!
  certificateType: EnglishCertificateType!
  content: String
  description: String
  explaination: String
  id: String
  image: String
  partId: String
  questionGroupName: String
  questionName: String!
  questionType: QuestionType!
  quickExplaination: String
  result: String!
  skillType: SkillsType!
  testId: String
}

input NewTestCategoryInput {
  certificateType: EnglishCertificateType
  displayOrder: Float
  displayOrderGroup: Float
  id: String
  isPublished: Boolean
  testCategoryName: String!
  testGroupId: String
}

input NewTestGroupInput {
  certificateType: EnglishCertificateType!
  displayOrder: Float!
  groupType: GroupType!
  id: String
  link: String!
  parentId: String
  testGroupName: String!
}

input NewTestInput {
  audioUrl: String
  certificateType: EnglishCertificateType
  description: String
  displayOrder: Float
  displayOrderCategory: Float
  explaination: String
  id: String
  isPublished: Boolean
  partAndAudioSecs: [AudioSecondsInput!]
  skillType: SkillsType
  testCategoryId: String
  testName: String
  testQuestionInputIds: TestQuestionInputIds
}

input NewUserInput {
  address: String
  email: String!
  firstName: String!
  lastName: String!
  password: String
  phone: String
  profileMediaUrl: String
  role: UserRole!
  socialLinks: SocialLinkInput
}

# Query Order Direction
enum OrderDirection {
  Asc
  Desc
}

type Part {
  certificateType: EnglishCertificateType!
  createdAt: DateTime!
  deleteAt: DateTime
  description: String!
  displayOrder: Float!
  id: String!
  partName: String!
  skillType: SkillsType!
  test: Test
  testQuestion: TestQuestion
  updatedAt: DateTime!
}

type PartAndAudioSeconds {
  autdioSecs: Float
  displayOrder: Float
  partId: String
}

input PartFilterInput {
  certificateType: EnglishCertificateType
  cursor: String
  orderDirection: OrderDirection
  partIds: PartIdsInput
  skillType: SkillsType
}

input PartIdAndQuestionIdsInput {
  partId: String
  questionIds: [String!]!
}

input PartIdsInput {
  ids: [String!]!
}

type Parts {
  nextCursor: String
  parts: [Part!]!
  total: Float!
}

type Query {
  getBlog(id: String!): Blog!
  getBlogs(data: BlogsSearchInput!): Blogs!
  getParts(data: PartFilterInput!): Parts!
  getPartsFromIds(data: PartIdsInput!): [Part!]!
  getTestCategories(data: TestCategoryFilterInput!): TestCategories!
  getTestCategory(id: String!): TestCategory!
  getTestGroup(id: String!): TestGroup!
  getTestGroups(data: TestGroupFilterInput!): TestGroups!
  getTestQuestions(testId: String!): [TestQuestion!]!
  getTests(data: TestFilterInput!): Tests!
  isEmailAlreadyExist(email: String!): Boolean!
  me: Me
  part(id: String!): Part!
  question(id: String!): Question!
  questions(questionFilterType: QuestionFilterTypeInput!): Questions!
  test(id: String!): Test!
  user(id: String!): User!
  users: [User!]!
}

type Question {
  answers: [Answers!]!
  audioSec: Float!
  audioSecVN: Float!
  certificateType: EnglishCertificateType!
  content: String
  createdAt: DateTime!
  deleteAt: DateTime
  description: String
  explaination: String
  id: String!
  image: String
  isGroup: Boolean!
  questionGroup: Question!
  questionGroupName: String
  questionGroupOrder: Float!
  questionGroups: [Question!]!
  questionName: String!
  questionType: QuestionType!
  quickExplaination: String
  result: String!
  skillType: SkillsType!
  testQuestion: TestQuestion
  updatedAt: DateTime!
}

input QuestionFilterTypeInput {
  certificateType: EnglishCertificateType!
  cursor: String
  orderDirection: OrderDirection
  skillType: SkillsType
  testId: String
  title: String
}

type Questions {
  nextCursor: String
  questions: [Question!]!
  total: Float!
}

enum QuestionType {
  FillBlank
  MultiChoice
  SingleChoice
}

enum SkillsType {
  Listening
  Reading
}

type SocialLink {
  facebook: String
  linkedin: String
  twitter: String
}

input SocialLinkInput {
  facebook: String
  linkedin: String
  twitter: String
}

type Test {
  audioUrl: String!
  certificateType: EnglishCertificateType!
  createdAt: DateTime!
  deleteAt: DateTime
  description: String!
  displayOrder: Float!
  displayOrderCategory: Float!
  explaination: String!
  id: String!
  isPublished: Boolean!
  part: Part
  partAndAudioSecs: [PartAndAudioSeconds!]
  skillType: SkillsType!
  testCategory: TestCategory
  testName: String!
  testQuestions: [TestQuestion!]
  updatedAt: DateTime!
}

type TestCategories {
  nextCursor: String
  testCategories: [TestCategory!]!
  total: Float!
}

type TestCategory {
  certificateType: EnglishCertificateType!
  createdAt: DateTime!
  deleteAt: DateTime
  displayOrder: Float!
  displayOrderGroup: Float!
  id: String!
  isPublished: Boolean!
  testCategoryName: String!
  testGroup: TestGroup
  tests: [Test!]
  updatedAt: DateTime!
}

input TestCategoryFilterInput {
  certificateType: EnglishCertificateType
  cursor: String
  orderDirection: OrderDirection
  testCategoryIds: TestCategoryIdsInput
}

input TestCategoryIdsInput {
  ids: [String!]!
}

input TestFilterInput {
  certificateType: EnglishCertificateType
  cursor: String
  orderDirection: OrderDirection
  skillType: SkillsType
  testIds: TestIdsInput
}

type TestGroup {
  blogs: [Blog!]!
  certificateType: EnglishCertificateType!
  createdAt: DateTime!
  deleteAt: DateTime
  displayOrder: Float!
  groupType: GroupType!
  id: String!
  isPublished: Boolean!
  link: String!
  parentId: String
  testCategories: [TestCategory!]
  testGroupChild: TestGroup!
  testGroupName: String!
  testGroupsChild: [TestGroup!]!
  updatedAt: DateTime!
}

input TestGroupFilterInput {
  certificateType: EnglishCertificateType
  cursor: String
  orderDirection: OrderDirection
  shouldGetChild: Boolean
}

type TestGroups {
  nextCursor: String
  testGroups: [TestGroup!]!
  total: Float!
}

input TestIdsInput {
  ids: [String!]!
}

type TestQuestion {
  createdAt: DateTime!
  deleteAt: DateTime
  displayOrder: Float!
  id: String!
  part: Part!
  question: Question!
  test: Test!
  updatedAt: DateTime!
}

input TestQuestionInputId {
  displayOrder: Float
  id: String
  partId: String
  questionId: String
  testId: String
}

input TestQuestionInputIds {
  partIdAndQuestionIdsInput: [PartIdAndQuestionIdsInput!]!
  testId: String
}

type Tests {
  nextCursor: String
  tests: [Test!]!
  total: Float!
}

input TestsUpdateInput {
  testCategoryId: String!
  testIds: TestIdsInput!
}

input UpdateBlogOrderInput {
  displayOrder: Float!
  id: String!
}

# Update me
input UpdateMeInput {
  address: String
  email: String
  firstName: String!
  id: String!
  lastName: String!
  password: String
  phone: String
  profileMediaUrl: String
  socialLinks: SocialLinkInput
}

type User {
  address: String
  blogs: [Blog!]!
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: String!
  isVerified: Boolean
  lastName: String
  level: String

  # First + Last name
  name: String!
  password: String
  phone: String
  profileMediaUrl: String
  role: String!
  socialLinks: SocialLink
  updatedAt: DateTime!
  version: Float!
}

# User Authorization Roles
enum UserRole {
  Admin
  Member
  Ops
}
